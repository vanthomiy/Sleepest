// Generated by TFLite Support.
package org.tensorflow.lite.classify;

import android.content.Context;
import android.graphics.Bitmap;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.tensorflow.lite.DataType;
import org.tensorflow.lite.Tensor.QuantizationParams;
import org.tensorflow.lite.support.common.FileUtil;
import org.tensorflow.lite.support.common.TensorProcessor;
import org.tensorflow.lite.support.common.ops.CastOp;
import org.tensorflow.lite.support.common.ops.DequantizeOp;
import org.tensorflow.lite.support.common.ops.NormalizeOp;
import org.tensorflow.lite.support.common.ops.QuantizeOp;
import org.tensorflow.lite.support.image.ImageProcessor;
import org.tensorflow.lite.support.image.TensorImage;
import org.tensorflow.lite.support.image.ops.ResizeOp;
import org.tensorflow.lite.support.image.ops.ResizeOp.ResizeMethod;
import org.tensorflow.lite.support.label.TensorLabel;
import org.tensorflow.lite.support.metadata.MetadataExtractor;
import org.tensorflow.lite.support.metadata.schema.NormalizationOptions;
import org.tensorflow.lite.support.model.Model;
import org.tensorflow.lite.support.model.Model.Device;
import org.tensorflow.lite.support.tensorbuffer.TensorBuffer;

/** Wrapper class of model Sleep-Raw-Api Sleep-classifier (Version: v1) */
public class MyModel {
  private final Metadata metadata;
  private final Model model;
  private static final String MODEL_NAME = "sleep_classifier_model.tflite";
  private final List<String> sleepstateLabels;
  @Nullable private ImageProcessor sleeprawapidatasetPreprocessor;
  @Nullable private TensorProcessor sleepstatePostprocessor;

  /** Input wrapper of {@link MyModel} */
  public class Inputs {
    private TensorImage sleeprawapidataset;

    public Inputs() {
      Metadata metadata = MyModel.this.metadata;
      sleeprawapidataset = new TensorImage(metadata.getSleeprawapidatasetType());
    }

    public void loadSleeprawapidataset(Bitmap bitmap) {
      sleeprawapidataset.load(bitmap);
      sleeprawapidataset = preprocessSleeprawapidataset(sleeprawapidataset);
    }

    public void loadSleeprawapidataset(TensorImage tensorImage) {
      sleeprawapidataset = preprocessSleeprawapidataset(tensorImage);
    }

    private TensorImage preprocessSleeprawapidataset(TensorImage tensorImage) {
      if (sleeprawapidatasetPreprocessor == null) {
        return tensorImage;
      }
      return sleeprawapidatasetPreprocessor.process(tensorImage);
    }

    Object[] getBuffer() {
      return new Object[] {sleeprawapidataset.getBuffer()};
    }
  }

  /** Output wrapper of {@link MyModel} */
  public class Outputs {
    private final TensorBuffer sleepstate;

    public Outputs() {
      Metadata metadata = MyModel.this.metadata;
      sleepstate = TensorBuffer.createFixedSize(metadata.getSleepstateShape(), metadata.getSleepstateType());
    }

    public Map<String, Float> getSleepstate() {
      return new TensorLabel(sleepstateLabels, postprocessSleepstate(sleepstate)).getMapWithFloatValue();
    }

    private TensorBuffer postprocessSleepstate(TensorBuffer tensorBuffer) {
      if (sleepstatePostprocessor == null) {
        return tensorBuffer;
      }
      return sleepstatePostprocessor.process(tensorBuffer);
    }

    Map<Integer, Object> getBuffer() {
      Map<Integer, Object> outputs = new HashMap<>();
      outputs.put(0, sleepstate.getBuffer());
      return outputs;
    }
  }

  /** Metadata accessors of {@link MyModel} */
  public static class Metadata {
    private final int[] sleeprawapidatasetShape;
    private final DataType sleeprawapidatasetDataType;
    private final QuantizationParams sleeprawapidatasetQuantizationParams;
    private final float[] sleeprawapidatasetMean;
    private final float[] sleeprawapidatasetStddev;
    private final int[] sleepstateShape;
    private final DataType sleepstateDataType;
    private final QuantizationParams sleepstateQuantizationParams;
    private final List<String> sleepstateLabels;

    public Metadata(ByteBuffer buffer, Model model) throws IOException {
      MetadataExtractor extractor = new MetadataExtractor(buffer);
      sleeprawapidatasetShape = extractor.getInputTensorShape(0);
      sleeprawapidatasetDataType = extractor.getInputTensorType(0);
      sleeprawapidatasetQuantizationParams = extractor.getInputTensorQuantizationParams(0);
      NormalizationOptions sleeprawapidatasetNormalizationOptions =
          (NormalizationOptions) extractor.getInputTensorMetadata(0).processUnits(0).options(new NormalizationOptions());
      FloatBuffer sleeprawapidatasetMeanBuffer = sleeprawapidatasetNormalizationOptions.meanAsByteBuffer().asFloatBuffer();
      sleeprawapidatasetMean = new float[sleeprawapidatasetMeanBuffer.limit()];
      sleeprawapidatasetMeanBuffer.get(sleeprawapidatasetMean);
      FloatBuffer sleeprawapidatasetStddevBuffer = sleeprawapidatasetNormalizationOptions.stdAsByteBuffer().asFloatBuffer();
      sleeprawapidatasetStddev = new float[sleeprawapidatasetStddevBuffer.limit()];
      sleeprawapidatasetStddevBuffer.get(sleeprawapidatasetStddev);
      sleepstateShape = model.getOutputTensorShape(0);
      sleepstateDataType = extractor.getOutputTensorType(0);
      sleepstateQuantizationParams = extractor.getOutputTensorQuantizationParams(0);
      String sleepstateLabelsFileName =
          extractor.getOutputTensorMetadata(0).associatedFiles(0).name();
      sleepstateLabels = FileUtil.loadLabels(extractor.getAssociatedFile(sleepstateLabelsFileName));
    }

    public int[] getSleeprawapidatasetShape() {
      return Arrays.copyOf(sleeprawapidatasetShape, sleeprawapidatasetShape.length);
    }

    public DataType getSleeprawapidatasetType() {
      return sleeprawapidatasetDataType;
    }

    public QuantizationParams getSleeprawapidatasetQuantizationParams() {
      return sleeprawapidatasetQuantizationParams;
    }

    public float[] getSleeprawapidatasetMean() {
      return Arrays.copyOf(sleeprawapidatasetMean, sleeprawapidatasetMean.length);
    }

    public float[] getSleeprawapidatasetStddev() {
      return Arrays.copyOf(sleeprawapidatasetStddev, sleeprawapidatasetStddev.length);
    }

    public int[] getSleepstateShape() {
      return Arrays.copyOf(sleepstateShape, sleepstateShape.length);
    }

    public DataType getSleepstateType() {
      return sleepstateDataType;
    }

    public QuantizationParams getSleepstateQuantizationParams() {
      return sleepstateQuantizationParams;
    }

    public List<String> getSleepstateLabels() {
      return sleepstateLabels;
    }
  }

  public Metadata getMetadata() {
    return metadata;
  }

  /**
   * Creates interpreter and loads associated files if needed.
   *
   * @throws IOException if an I/O error occurs when loading the tflite model.
   */
  public MyModel(Context context) throws IOException {
    this(context, MODEL_NAME, Device.CPU, 1);
  }

  /**
   * Creates interpreter and loads associated files if needed, but loading another model in the same
   * input / output structure with the original one.
   *
   * @throws IOException if an I/O error occurs when loading the tflite model.
   */
  public MyModel(Context context, String modelPath) throws IOException {
    this(context, modelPath, Device.CPU, 1);
  }

  /**
   * Creates interpreter and loads associated files if needed, with device and number of threads
   * configured.
   *
   * @throws IOException if an I/O error occurs when loading the tflite model.
   */
  public MyModel(Context context, Device device, int numThreads) throws IOException {
    this(context, MODEL_NAME, device, numThreads);
  }

  /**
   * Creates interpreter for a user-specified model.
   *
   * @throws IOException if an I/O error occurs when loading the tflite model.
   */
  public MyModel(Context context, String modelPath, Device device, int numThreads) throws IOException {
    model = new Model.Builder(context, modelPath).setDevice(device).setNumThreads(numThreads).build();
    metadata = new Metadata(model.getData(), model);

    ImageProcessor.Builder sleeprawapidatasetPreprocessorBuilder = new ImageProcessor.Builder()
        .add(new ResizeOp(
            metadata.getSleeprawapidatasetShape()[1],
            metadata.getSleeprawapidatasetShape()[2],
            ResizeMethod.NEAREST_NEIGHBOR))
        .add(new NormalizeOp(metadata.getSleeprawapidatasetMean(), metadata.getSleeprawapidatasetStddev()))
        .add(new QuantizeOp(
            metadata.getSleeprawapidatasetQuantizationParams().getZeroPoint(),
            metadata.getSleeprawapidatasetQuantizationParams().getScale()))
        .add(new CastOp(metadata.getSleeprawapidatasetType()));
    sleeprawapidatasetPreprocessor = sleeprawapidatasetPreprocessorBuilder.build();

    TensorProcessor.Builder sleepstatePostprocessorBuilder = new TensorProcessor.Builder()
        .add(new DequantizeOp(
            metadata.getSleepstateQuantizationParams().getZeroPoint(),
            metadata.getSleepstateQuantizationParams().getScale()));
    sleepstatePostprocessor = sleepstatePostprocessorBuilder.build();

    sleepstateLabels = metadata.getSleepstateLabels();
  }

  public void resetSleeprawapidatasetPreprocessor(@Nullable ImageProcessor processor) {
    sleeprawapidatasetPreprocessor = processor;
  }

  public void resetSleepstatePostprocessor(@Nullable TensorProcessor processor) {
    sleepstatePostprocessor = processor;
  }

  /** Creates inputs */
  public Inputs createInputs() {
    return new Inputs();
  }

  /** Triggers the model. */
  public Outputs run(Inputs inputs) {
    Outputs outputs = new Outputs();
    model.run(inputs.getBuffer(), outputs.getBuffer());
    return outputs;
  }

  /** Closes the model. */
  public void close() {
    model.close();
  }
}

